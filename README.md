# Lace: Diagnostic logging and tracing tools for python

## Introduction

Lace provides a small but powerful set of tools for inspecting and diagnosing
programmatic problems in place without modifying pre-existing code.  With the
use of decorators, functions can be modified unobtrusively to present active
trace information at run-time along with arguments and keyword arguments.

In addition to tracing utilities, Lace includes hooks to the built-in python
logging module.

## Installation

Installation is done using `setuptools`.  If you do not already have
`setuptools` on your machine, run the following:
```
pip install setuptools
```

All that is needed to use Lace is to run the setup script.
```
python setup.py build install
```

You should now have Lace available to your python environment

## Usage

### Activating Lace

**Important:** Tracing in lace is _INACTIVE_ by default.  This is a performance consideration.
Much like adding debug symbols in gdb, adding logging traces incurs significant performance costs.

There are two ways to enable tracing.  The first is programmatically with the `trace.enabled` function.

```
from lace import logging
logging.trace.enabled(True)
```

This method has an important consideration, however.  Any trace decorators called before enabling
cannot be recovered.  If tracing is enabled after object construction, most of the logging symbols
will be lost already.

To instead enable tracing for an entire session, include the environment variable `LACE_TRACE_ON`
in the session, either by exporting the variable or by including it with your python call.

```
LACE_TRACE_ON=true python my_cool_app.py
```

-or-

```
export LACE_TRACE_ON=true
python my_cool_app.py
```

### Logging

Logging utilities in Lace are available in the logging module
```python
from lace import logging
```

Lace inherits the behavior of the built-in python logging systme, clients may
configure their own formatters/filters/handlers as needed.

Lace adds the `color` and `reset` fields to the LogRecord object generated by
a logging message.  This allows these names to be included as additional
fields in the formatting string used by loggers.  For instance, the following
will create a logger that formats messages to colorize the metadata about
the message, then print the message itself in the default terminal color.

```python
import logging
logger = logging.getLogger()
stderr = logging.StreamHandler()
format = logging.Formatter("{color}[{levelname} {asctime} {name}]{reset} {message}")
stderr.setFormatter(format)
stderr.setLevel(lace.logging.TRACE_ALL)
logger.addHandler(stderr)
```

Lace also provides three new named logging levels:

| Name 	   | Levelno | Description                                           |
| -------- | ------- | ----------------------------------------------------- |
| `TLONG`  | 5       | Includes "private" function calls that start with `_` |
| `TSHORT` | 6       | Includes calls to "public" functions                  |
| `TNEW`   | 7       | Logs calls to `__init__` functions                    |

See https://docs.python.org/3/library/logging.html for more

### Tracing

Tracing can be enabled on either classes or individual functions with decorators.
The most efficient method for generating tracing logs is through class decorators.

```python
from lace.logging import trace

@trace("mytrace")
class Foo(object):
    def __init__(self, a, b):
        self.a, self.b = a, b

    def bar(self, z):
        return self.a + z

    def _baz(self, f="other"):
        return "{}.{}".format(self.bar(self.b), f)
```

The above gist will generate trace three types of trace message.  An object creation message
will be generated around `__init__`, a public message will be generated for `bar` and a private
message will be generated for `_baz`.  The namespaces generated by the above example are
`mytrace.Foo.new`, `mytrace.Foo.bar`, `mytrace.Foo._baz`.  We will not go into detail here about
using logging namespaces, but it is worth noting that these are available for client use in filtering
and locating events of interest.

The messages generated in the previous gist are not printed to `stderr` or `stdout` automatically.
In order to access them, you must first create a logger and specify it's behavior.  This works
as the built-in logging environment linked above.  Here is a quick gist of how to print the output
to the screen.

```python
import logging
logger = logging.getLogger("mytrace")
stderr = logging.StreamHandler()
format = logging.Formatter("{color}[{levelname} {asctime} {name}]{reset} {message}")
stderr.setFormatter(format)
stderr.setLevel(lace.logging.TRACE_ALL)
logger.addHandler(stderr)
```

This logger uses the `mytrace` namespace and will only recieve messages from messages within
that namespace and will output as so:

```
>>> f = Foo(5, 10)
[TNEW 12:48:23,048 mytrace.Foo.New] args=[obj_Foo, 5, 10]
>>> f._baz(f="hello")
[TLONG 12:49:00,000 mytrace.Foo._baz] args=[obj_Foo], kwargs={f: "hello"}
[TSHORT 12:49:00,001 mytrace.Foo.bar] args=[obj_Foo, 10]
15.hello
```

On a console with ANSI codes enabled, the segment in brackets would also be colored based on the level
of the message.  

`trace` provides a number of quality-of-life functions usually used in conjunction, but can be
enabled separately as needed.  The first is the `showCallDepth` function, which adds a depth padding
the each message.  Using the same `Foo` object before:

```python
from lace.logging import trace
import logging 
logger = logging.getLogger("mytrace")
stderr = logging.StreamHandler()
format = logging.Formatter("{color}[{levelname:.2}] {message} > {name}
stderr.setFormatter(format)
stderr.setLevel(lace.logging.TRACE_ALL)
trace.showCallDepth(True)
```

```
>>> f = Foo(5, 10)
[TN] --args=[obj_Foo, 5, 10] > mytrace.Foo.New
>>> f._baz(f="hello")
[TL] --args=[obj_foo], kwargs={f: "hello"} > mytrace.Foo._baz
[TS] ----args=[obj_foo, 10] > mytrace.Foo.bar
15.hello
```

Furthermore, by enabling return values with `showReturn`, `trace` will log the return values
for each function.

```python
trace.showReturn(True)
```

```
>>> f._baz(f="hello")
[TL] --args=[obj_foo], kwargs={f: "hello"} > trace.Foo_baz
[TS] ----args=[obj_foo, 10] > mytrace.Foo.bar
[TS] <<<< 15
[TL] << 15.hello
15.hello
```

### Function Decorators

By decorating a function with the trace.<level> function which takes one 
argument (the module the function is contained in), diagnostic information
can be selectively included in the output.

```
class MyClass(object):
      @trace.info("MyClass")
      def __init__(self, value):
      	  self.foo(10, y=5)
      	  
      @trace.debug("MyClass")
      def foo(self, x, y):
      	  pass
```

The above code, when `mc = MyClass(5)` was called, would print:
```
[IN 2017-04-24 14:09:05,530 MyClass.__init__] args=[5]
[DE 2017-04-24 14:09:05,531 MyClass.foo] args=[10], kwargs={y: 5}
```
